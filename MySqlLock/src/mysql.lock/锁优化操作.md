# 8.11 优化锁操作

MySQL使用锁来管理对表内容的争抢：
* MySQL服务器自身执行内部锁，内部锁通过多线程管理对表内容的争抢。这种锁称为内部锁的原因是完全由服务器执行并且和其它程序没有关系。
* 外部锁发生在服务器和其它程序锁定MyISAM表文件的时候，通过外部锁协调在什么时间哪些程序可以访问表

## 8.11.1 内部锁定方法

本节讨论内部锁。也就是说在MySQL服务器本身执行，通过多个会话管理对表内容的争抢。因为只在服务器内部执行，和其它程序无关，所以成为内部锁。

### 行级锁

MySQL在InnoDB表中使用了行级锁，用来支持多个会话同时的写访问，使InnoDB引擎适用于多用户，高并发和OLTP应用。
为了避免在单个表上执行多并发写操作的时候发生死锁，对于期望做出修改的一组操作，InnoDB通过`SELECT
... FOR
UPDATE`语句，在事物一开始的时候获取一个锁，即使数据修改的语句在事物中出现的比较晚。如果事物中修改或锁定了多个表，以事物的修改顺序发出同样的适用语句。死锁影响性能，但不会抛出严重错误，因为InnoDB自动检测死锁，并且回滚其中一个受影响的事物。
在高并发心痛中，当多个线程等待同一个锁时，死锁检测会导致速度减慢。有时，禁用死锁检测可能会更高效。参数**innodb_lock_wait_timeout**用于死锁发生时事物的回滚，参数**innodb_deadlock_detect**用于配置死锁检测。

行锁的特点:
* 当不同的会话访问不同的行时，更少的锁冲突。
* 回滚时更少的变化。
* 可以长时间锁定一行数据。

### 表级锁

MySQL使用表级锁的MyISAM， MEMORY和MERGE 表，一次只允许一个会话更新这些表。此锁定级别使这些存储引擎更适合于只读，大多数读取或单用户应用程序。
这些存储引擎通过始终在查询开始时立即请求所有需要的锁并始终以相同的顺序锁定表来避免死锁。权衡是这种策略降低了并发性;
其他想要修改表的会话必须等到当前数据更改语句完成。

表锁的特点:
* 较少的内存（每个行锁或者每个行组都需要内存）
* 当需要使用表内大部分数据的时候更快，因为只涉及一个锁。
* 如果经常对大部分数据使用GROUP BY操作，或者经常扫描整个表，表锁更快。

MySQL通过如下方式授予一个表写锁:
1. 如果表上没有锁，授予一个写锁在上面。
2. 否则，将写锁放入写锁队列。

MySQL通过如下方式授予一个表读锁:
1. 如果表上没有写锁，授予一个读锁在上面。
2. 否则，将读锁放入读锁队列。

表更新操作的优先级要高于表检索操作。因此，当一个锁空闲的时候，这个锁先用于写锁队列，再用于读锁队列。这保证了在表上又大量SELECT活动的时候，也能进行更新。然而，如果表上有大量的更i性能，SELECT语句必须等到更新的量不是那么多。

### 选择锁定类型

通常，在以下情况下，表锁比行锁适用:
* 该表的大多数语句是读语句。
* 该表的语句混合了读写，且写语句是单行的更新或删除，这一行可以通过一个关键词匹配出来
* SELECT语句结果并发的 INSERT语句，和很少的 UPDATE 或 DELETE语句。
* 在没有写操作的情况下许多的扫描或者是 GROUP BY操作

使用高级别的锁，你可以更容易的通过支持不同类型的锁来调整应用程序，因为高级别锁的开销要低于行锁。

行锁以外的选项:
* 版本控制（例如MySQL中用于并发插入的版本控制），可能在有多个读操作的同时有一个写操作。这意味着数据库或者表在访问开始的时候，支持给数据创建不同的视图。通常的叫法也有“时间旅行”，“写时复制”或“按需复制”
* 在大多数情况下，按需复制优于行锁。然而在最坏的情况下，按需复制会比一般的锁使用更多的内存
* 可以使用应用级别的锁来替换行锁，例如MySQL提供的 GET_LOCK()和 RELEASE_LOCK()。他们是咨询锁，所以仅适用于彼此协作的应用程序。

## 8.11.2 表锁问题

InnoDB的表使用行锁。所以多个会话和应用可以同时读取和写入同一张表，且不会造成彼此等待或者产生不一致的后果。对于这样的存储引擎，请尽量不要使用LOCK
TABLES语句，因为这种语句没有提供任何额外的保护，反而降低了并发性。自动行级锁使表适用于最繁忙的数据库，存储最重要的数据，同事简化了应用逻辑，因为不需要锁定和解锁表，所以InnoDB是MySQL默认的存储引擎。
MySQL给除了InnoDB引擎外的所有引擎使用了表锁（而不是页锁、行锁或列锁）。加锁操作本身没有多少开销，但是会导致在任一时候只能有一个会话可以写入表，所以为了使这些引擎获取最好的性能，主要将他们用于查询很多单插入或更新很少的表。

在选择使用InnoDB或者其它存储引擎的时候，请记住表锁的以下缺点:
* 表锁允许多个会话同时读取，但如果一个会话想要写入，它必须首先获取排他访问权，意味着它必须等待其它会话结束。在它更新期间，其它想要访问此表的会话也必须等待更新结束。
* 如果磁盘已满且没有可用空间，那么这个会话会一直等待，且后续所有会话都必须等待。
* 一个耗时较长的查询语句，会阻止其它的更新语句，造成其它会话响应缓慢。当一个会话想要获取排他权限更新的话，其它想要查询的会话也必须
  等待，降低了只读会话的并发性

### 锁性能导致问题的变通方法

以下各项描述了减少表锁竞争的方法:
* 改变表的存储引擎为InnoDB，在创建表时使用`create table ...
  engine=innodb`语句，或者使用`alter table ... engine=innodb`语句修改表。
* 优化查询语句，减少锁表的时间。你可能需要一些汇总表来进行SQL优化。
* 以**low-priority-updates**启动mysqld，对于只使用表锁的存储引擎（思如MyISAM，MEMORY和MERGE），这个命令
  会使所有的更新语句优先级低于查询语句。在这种情景下，第二个查询语句会在更新语句之前执行，且不会等待第一个查询语句完成。
* 要在一个特定的连接中设置所有的更新语句优先级低于查询语句，请将系统变量**low_priority_updates**设置为1
* 要将一个指定的**INSERT**、**UPDATE**或**DELETE**语句优先级降低，请使用**LOW_PRIORITY**属性
* 要将一个指定的查询语句提高优先级，请使用**HIGH_PRIORITY**属性
* 设置系统变量**max_write_lock_count**为一个较低的值，然后启动mysqld。在一个特殊更新表操作的数量
  之后的所有语句，MySQL会强制提升他们的优先级，这个允许在一定数量的写锁之后使用读锁。
* 如果你在使用**INSERT**联合**SELECT**语句的时候有问题，考虑更换为**MyISAM**表，这种表支持并发读操作和写操作
* 如果你在混合使用**SELECT**和**DELETE**语句的时候有问题，在使用**DELETE**的时候使用**LIMIT**限制可能会有帮助
* 在使用**SELECT**语句时使用**SQL_BUFFER_RESULT**，可以使表锁持续的时间缩短。
* 将表内容拆分为两个表，其中一个表查询，另一个表更新
* 你可以改变在**mysys/thr_lock.c**文件中的锁代码，用来使用一个单独的队列。在这种情境下，读锁和写锁将拥有同样的优先级，
  这可能会帮助某些应用程序。

## 8.11.3 并发插入

MyISAM存储引擎支持并发插入，减少对于表读和写之间的竞争。如果MyISAM表的数据没有断档（从中间删除了数据），
那么可以在查询语句正在执行的时候，执行一个插入语句，并且将数据加到表的最后。如果是多个插入语句，他们将
会在一个队列中顺序执行，并发插入的结果不是立即可见的.

**concurrent_insert**系统变量可以被修改。通常情况下，这个值被设置成**AUTO**（或1），并发插入的表现如前文所述。如果被设置为**NEVER**（或0），禁止并发插入功能。如果被设置为**ALWAYS**（或2），那么即使表中有删除的行，也允许并发插入。

如果你正在使用二进制日志，并发插入将会转换为`CREATE ... SELECT`或`INSERT ...
SELECT`语句。这保证了在使用日志文件作为备份重建表时数据的正确性。对于这些语句，被SELECT的表将会有一个读锁，且此表的插入也会被阻止。

## 8.11.4 元数据锁

MySQL使用元数据锁管理对数据库对象的并发访问和保证数据一致性。元数据锁不仅能应用在表上，也能应用到模式、存储过程和表空间。

**metadata_locks**表暴露了元数据所的信息，可以查看哪些会话持有锁，哪些会话在阻塞中等等细节。

元数据锁会增加一些开销，随着查询量的增加而增加。在多个查询试图访问同一个对象的时候，元数据所的竞争会增长很多。

元数据锁不是表定义缓存的代替，以下讨论了元数据锁是怎么工作的

### 元数据锁获取

如果对于锁有多个请求（包括读锁写锁），更高优先级的锁请求优先被满足，并且与**max_write_lock_count**系统变量有关。写锁比读锁有更高的优先级。但是如果**max_wtite_lock_count设定为一个较低的值（例如10），那么10个挂起的写锁请求后的读锁请求，优先级要比读锁高，这种情况一般不会发生，因为此系统变量一般是很大的值。

语句逐个请求元数据锁，不会并发请求，并且在此过程中执行死锁检测。

DML语句按表再语句中提到的顺序去获取锁。

DDL语句，锁表和其它类似的语句，通过按照显示使用的表的名称顺序获取锁，以减少并发DDL语句之间死锁的可能。对于隐式使用的表（例如外键关联的表），可能以不同的表名称顺序获取锁。

例如，重命名表是一种按表名顺序获取锁的DDL语句：
* 下面的语句将tbla重命名为tbld，将tblc重命名为tbla;

  ```
  RENAME TABLE tbla TO tbld, tblc TO tbla;
  ```

  这个语句按照tbla、tblc、tbld的顺序获取锁。
* 下面的语句将tbla重命名为tblb,将tblc重命名为tbla;

  ```
  RENAME TABLE tbla TO tblb, tblc TO tbla;
  ```

  这个语句按照tbla、tblb、tblc的顺序获取锁。

这两个语句都按照顺序在tbla和tblc上获取锁，不同点是剩下的表名的锁是在tblc之前还是之后获取。

多个事物同时执行的时候，元数据锁的获取顺序会导致不同的操作结果，接下来用例子说明。

准备两个结构完全相同的表，3个涉及这张表的客户端：

客户端1：

```
LOCK TABLE x WRITE, x_new WRITE;
```

这个语句按x、x_new的顺序请求和获取了写锁。

客户端2：

```
INSERT INTO x VALUES(1);
```

这个语句在x上请求写锁并阻塞。

客户端3：

```
RENAME TABLE x TO x_old, x_new TO x;
```

这个语句按x、x_new和x_old的顺序获取排他锁，但是在获取x上的锁时阻塞。

客户端1：

~~~
UNLOCK TABLES;
~~~

这个语句释放在x和x_new上的写锁。客户端3对x排他锁的请求比客户端2写锁的请求优先级高，所以客户端3获取x上的锁，同样获取x_new、x_old的锁，执行重命名，然后释放锁。最后客户端2获取x上的锁，执行插入语句，然后释放锁。

锁获取的顺序导致了**RENAME
TABLE**的执行发生在**INSERT**之前。客户端2插入数据的表，其实就是客户端3之前重命名为x的表x_new,以下查询可以证明：
~~~
mysql> SELECT * FROM x;
+------+
| i    |
+------+
|    1 |
+------+

mysql> SELECT * FROM x_old;
Empty set (0.01 sec)
~~~

现在重新创建两张结构完全一致的表x和new_x，开启3个涉及表的客户端：

客户端1：

~~~
LOCK TABLE x WRITE, new_x WRITE;
~~~

这个语句按照new_x和x的顺序请求并获取了锁。

客户端2：

~~~
INSERT INTO x VALUES(1);
~~~

这个语句请求表x的锁并阻塞。

客户端3：

~~~
RENAME TABLE x TO old_x, new_x TO x;
~~~

这个语句按照new_x, old_x和x的顺序请求排他锁，但是在表new_x上阻塞。

客户端1：

~~~
UNLOCK TABLES;
~~~

这个语句释放了表x和new_x的写锁。对于表x，唯一等待的请求时客户端2的，客户端2获取锁，执行插入，释放锁。对于表new_x,唯一等待的请求时客户端3的，客户端3能获取new_x的锁（同时也获取old_x的锁）。重命名操作同时也会在客户端2插入结束释放掉表x的锁后，获取表x的锁。客户端3获取锁后，执行重命名，释放锁。

锁的获取顺序导致了**INSERT**的执行发生在**RENAME
TABLE**之前。插入数据的表x，就是之前的表x，现在被重命名为old_x，以下查询可以证明：
~~~
mysql> SELECT * FROM x;
Empty set (0.01 sec)

mysql> SELECT * FROM old_x;
+------+
| i    |
+------+
|    1 |
+------+
~~~
如果并发语句中锁的获取顺序导致了不同的操作结果，你可以通过调整表名来改变锁的获取顺序。

### 元数据锁的释放

为了保证事物的串行化，在一个会话对一张表显式的或隐式的开启一个事物且没有结束的时候，服务器不允许另一个会话在此表上执行DDL语句。一个事物开始时要获取表上的元数据锁，在事物结束时，锁会延迟释放，通过这种方式，服务器实现了事物串行化。一个表上的元数据锁阻止了表结构的改变。一个表上的元数据锁意味着这个表正在被一个会话的事物使用，直到这个事物结束，此表不能被用于DDL语句。

这个原理不仅适用于事物表，也适用于非事物表。如下一个会话开启事务后，对事物表t和非事物表nt进行了操作：
~~~
START TRANSACTION;
SELECT * FROM t;
SELECT * FROM nt;
~~~
服务器持有t和nt的元数据锁知道事物结束。如果另一个会话试图对任一张表执行DDL语句或者想要获取写锁，都会阻塞知道元数据锁被释放。例如另一个会话的以下操作都会被阻塞：
~~~
DROP TABLE t;
ALTER TABLE t ...;
DROP TABLE nt;
ALTER TABLE nt ...;
LOCK TABLE t ... WRITE;
~~~

同样的行为适用于**LOCK TABLES ...
READ**语句。也就是说，对于一张表的任何更新操作（事物的或者非事物的），显式或隐式的开启事物，都会因为**LOCK
TABLES ... READ**而阻塞。

如果一个语句合法的获取了元数据锁，但是执行失败了，元数据锁不会提前释放，依然会在事物结束后延迟释放。因为失败的语句被写入了二进制日志，锁要保证日志的连贯性。

在自动提交模式下，每个语句实际上都是一个完整的事务，因此为语句获取的元数据锁只保留在语句的末尾。

