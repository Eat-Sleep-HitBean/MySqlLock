# 8.11 优化锁操作

MySQL使用锁来管理对表内容的争抢：
* MySQL服务器自身执行内部锁，内部锁通过多线程管理对表内容的争抢。这种锁称为内部锁的原因是完全由服务器执行并且和其它程序没有关系。
* 外部锁发生在服务器和其它程序锁定MyISAM表文件的时候，通过外部锁协调在什么时间哪些程序可以访问表

## 8.11.1 内部锁定方法
本节讨论内部锁。也就是说在MySQL服务器本身执行，通过多个会话管理对表内容的争抢。因为只在服务器内部执行，和其它程序无关，所以成为内部锁。

### 行级锁
MySQL在InnoDB表中使用了行级锁，用来支持多个会话同时的写访问，使InnoDB引擎适用于多用户，高并发和OLTP应用。
为了避免在单个表上执行多并发写操作的时候发生死锁，对于期望做出修改的一组操作，InnoDB通过`SELECT ... FOR UPDATE`语句，在事物一开始的时候获取一个锁，即使数据修改的语句在事物中出现的比较晚。如果事物中修改或锁定了多个表，以事物的修改顺序发出同样的适用语句。死锁影响性能，但不会抛出严重错误，因为InnoDB自动检测死锁，并且回滚其中一个受影响的事物。
在高并发心痛中，当多个线程等待同一个锁时，死锁检测会导致速度减慢。有时，禁用死锁检测可能会更高效。参数**innodb_lock_wait_timeout**用于死锁发生时事物的回滚，参数**innodb_deadlock_detect**用于配置死锁检测。

行锁的特点:
* 当不同的会话访问不同的行时，更少的锁冲突。
* 回滚时更少的变化。
* 可以长时间锁定一行数据。

### 表级锁
MySQL使用表级锁的MyISAM， MEMORY和MERGE 表，一次只允许一个会话更新这些表。此锁定级别使这些存储引擎更适合于只读，大多数读取或单用户应用程序。
这些存储引擎通过始终在查询开始时立即请求所有需要的锁并始终以相同的顺序锁定表来避免死锁。权衡是这种策略降低了并发性; 其他想要修改表的会话必须等到当前数据更改语句完成。

表锁的特点:
* 较少的内存（每个行锁或者每个行组都需要内存）
* 当需要使用表内大部分数据的时候更快，因为只涉及一个锁。
* 如果经常对大部分数据使用GROUP BY操作，或者经常扫描整个表，表锁更快。

MySQL通过如下方式授予一个表写锁:
1. 如果表上没有锁，授予一个写锁在上面。
2. 否则，将写锁放入写锁队列。

MySQL通过如下方式授予一个表读锁:
1. 如果表上没有写锁，授予一个读锁在上面。
2. 否则，将读锁放入读锁队列。

表更新操作的优先级要高于表检索操作。因此，当一个锁空闲的时候，这个锁先用于写锁队列，再用于读锁队列。这保证了在表上又大量SELECT活动的时候，也能进行更新。然而，如果表上有大量的更i性能，SELECT语句必须等到更新的量不是那么多。

### 选择锁定类型
通常，在以下情况下，表锁比行锁适用:
* 该表的大多数语句是读语句。
* 该表的语句混合了读写，且写语句是单行的更新或删除，这一行可以通过一个关键词匹配出来
* SELECT语句结果并发的 INSERT语句，和很少的 UPDATE 或 DELETE语句。
* 在没有写操作的情况下许多的扫描或者是 GROUP BY操作

使用高级别的锁，你可以更容易的通过支持不同类型的锁来调整应用程序，因为高级别锁的开销要低于行锁。

行锁以外的选项:
* 版本控制（例如MySQL中用于并发插入的版本控制），可能在有多个读操作的同时有一个写操作。这意味着数据库或者表在访问开始的时候，支持给数据创建不同的视图。通常的叫法也有“时间旅行”，“写时复制”或“按需复制”
* 在大多数情况下，按需复制优于行锁。然而在最坏的情况下，按需复制会比一般的锁使用更多的内存
* 可以使用应用级别的锁来替换行锁，例如MySQL提供的 GET_LOCK()和 RELEASE_LOCK()。他们是咨询锁，所以仅适用于彼此协作的应用程序。

## 8.11.2 表锁问题
InnoDB的表使用行锁。所以多个会话和应用可以同时读取和写入同一张表，且不会造成彼此等待或者产生不一致的后果。对于这样的存储引擎，请尽量不要使用LOCK TABLES语句，因为这种语句没有提供任何额外的保护，反而降低了并发性。自动行级锁使表适用于最繁忙的数据库，存储最重要的数据，同事简化了应用逻辑，因为不需要锁定和解锁表，所以InnoDB是MySQL默认的存储引擎。
MySQL给除了InnoDB引擎外的所有引擎使用了表锁（而不是页锁、行锁或列锁）。加锁操作本身没有多少开销，但是会导致在任一时候只能有一个会话可以写入表，所以为了使这些引擎获取最好的性能，主要将他们用于查询很多单插入或更新很少的表。

在选择使用InnoDB或者其它存储引擎的时候，请记住表锁的以下缺点:
* 表锁允许多个会话同时读取，但如果一个会话想要写入，它必须首先获取排他访问权，意味着它必须等待其它会话结束。在它更新期间，其它想要访问此表的会话也必须等待更新结束。
* 如果磁盘已满且没有可用空间，那么这个会话会一直等待，且后续所有会话都必须等待。
* 一个耗时较长的查询语句，会阻止其它的更新语句，造成其它会话响应缓慢。当一个会话想要获取排他权限更新的话，其它想要查询的会话也必须
等待，降低了只读会话的并发性

### 锁性能导致问题的变通方法
以下各项描述了减少表锁竞争的方法:
* 改变表的存储引擎为InnoDB，在创建表时使用`create table ... engine=innodb`语句，或者使用`alter table ... engine=innodb`语句修改表。
* 优化查询语句，减少锁表的时间。你可能需要一些汇总表来进行SQL优化。
* 以**low-priority-updates**启动mysqld，对于只使用表锁的存储引擎（思如MyISAM，MEMORY和MERGE），这个命令
会使所有的更新语句优先级低于查询语句。在这种情景下，第二个查询语句会在更新语句之前执行，且不会等待第一个查询语句完成。
* 要在一个特定的连接中设置所有的更新语句优先级低于查询语句，请将系统变量**low_priority_updates**设置为1
* 要将一个指定的**INSERT**、**UPDATE**或**DELETE**语句优先级降低，请使用**LOW_PRIORITY**属性
* 要将一个指定的查询语句提高优先级，请使用**HIGH_PRIORITY**属性
* 设置系统变量**max_write_lock_count**为一个较低的值，然后启动mysqld。在一个特殊更新表操作的数量
之后的所有语句，MySQL会强制提升他们的优先级，这个允许在一定数量的写锁之后使用读锁。
* 如果你在使用**INSERT**联合**SELECT**语句的时候有问题，考虑更换为**MyISAM**表，这种表支持并发读操作和写操作
* 如果你在混合使用**SELECT**和**DELETE**语句的时候有问题，在使用**DELETE**的时候使用**LIMIT**限制可能会有帮助
* 在使用**SELECT**语句时使用**SQL_BUFFER_RESULT**，可以使表锁持续的时间缩短。
* 将表内容拆分为两个表，其中一个表查询，另一个表更新
* 你可以改变在**mysys/thr_lock.c**文件中的锁代码，用来使用一个单独的队列。在这种情境下，读锁和写锁将拥有同样的优先级，
这可能会帮助某些应用程序。

## 8.11.3 并发插入
MyISAM存储引擎支持并发插入，减少对于表读和写之间的竞争。如果MyISAM表的数据没有断档（从中间删除了数据），
那么可以在查询语句正在执行的时候，执行一个插入语句，并且将数据加到表的最后。如果是多个插入语句，他们将
会在一个队列中顺序执行，并发插入的结果不是立即可见的.

**concurrent_insert**系统变量可以被修改。通常情况下，这个值被设置成**AUTO**（或1），并发插入的表现如前文所述。如果被设置为**NEVER**（或0），禁止并发插入功能。如果被设置为**ALWAYS**（或2），那么即使表中有删除的行，也允许并发插入。

如果你正在使用二进制日志，并发插入将会转换为`CREATE ... SELECT`或`INSERT ... SELECT`语句。这保证了在使用日志文件作为备份重建表时数据的正确性。对于这些语句，被SELECT的表将会有一个读锁，且此表的插入也会被阻止。

## 8.11.4 元数据锁
MySQL使用元数据锁管理对数据库对象的并发访问和保证数据一致性。元数据锁不仅能应用在表上，也能应用到模式、存储过程和表空间。

**metadata_locks**表暴露了元数据所的信息，可以查看哪些会话持有锁，哪些会话在阻塞中等等细节。

元数据锁会增加一些开销，随着查询量的增加而增加。在多个查询试图访问同一个对象的时候，元数据所的竞争会增长很多。

元数据锁不是表定义缓存的代替，以下讨论了元数据锁是怎么工作的

### 元数据锁获取



















