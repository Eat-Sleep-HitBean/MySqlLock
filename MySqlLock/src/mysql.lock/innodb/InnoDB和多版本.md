* [返回目录](../InnoDB目录.md)

---

# InnoDB和多版本

InnoDB是一个多版本的存储引擎：它保留了已更改行的旧版本信息，以支持并发和回滚等事物功能。此信息保存在表空间中名为回滚段的数据结构中。在事物回滚的时候，InnoDB使用回滚段中的信息进行撤销操作。InnoDB还使用此信息构建行数据的早期版本用来进行一致性读。

在内部，InnoDB给数据库中保存的每一行数据添加3个字段。一个6字节的**DB_TRX_ID**表示插入或者更新行数据的最后一个事物的事物标识符。此外，删除在内部被视为更新操作，行数据的一个特殊位将会被用来标记删除。每一行也包含一个称为回滚指针的7字节字段**DB_ROLL_PTR**。回滚指针指向回滚段中写入的undo-log。如果行更新了，那么undo-log记录包含了此行数据重建更新前内容所需要的所有信息。一个6字节的**DB_ROW_ID**字段包含了一个在插入新行时单调递增的ID。如果InnoDB自动创建了聚簇索引，那么聚簇索引包含行ID值。否则，**DB_ROW_ID**列不会出现在任何索引中。

回滚段中的undo-log被分为插入undo-log和更新undo-log。插入undo-log只有在事物回滚的时候需要并且可以在事物提交后立即丢弃。更新undo-log也用于一致性读，但是只有在InnoDB没有已分配快照的事物以后，才能丢弃，因为快照是通过更新undo-log中的信息来构建早期版本的数据行的。

定期提交你的事物，包括那些只进行一致性读的事物。否则的话，InnoDB无法丢弃更新undo-log中的数据，回滚段会一直增大，从而填满表空间。

回滚端中undo-log的物理大小通常小于插入或更新的行，你可以通过此信息计算所需要的回滚段空间。

在InnoDB多版本方案中，当你用SQL语句删除一行数据时，这行数据不会立刻物理删除。只有当InnoDB丢弃更新undo-log中关于此删除操作的信息时，才会物理删除对应行的数据和索引信息。这个移除操作叫[清除](#清除)，清除操作非常快，并且和删除语句的时间顺序一致。

如果以相同的速率一直进行小批量的插入和删除，清除线程有可能落后，并且表会变的越来越大，因为有很多“被删除”的行没有进行物理删除。在这种情况下，通常通过调整**innodb_max_purge_lag**系统变量来限制新行操作，分配更多资源给清除线程。

# 多版本和二级索引
InnoDB的MVCC对聚簇索引和二级索引的处理方式不同。聚簇索引就地更新，并且系统隐藏的列指向undo-log中可以用来重建的早期版本的记录。不同于聚簇索引，二级索引记录不包含隐藏的系统列，也不会就地更新。

当一个二级索引列被更新，旧的二级索引记录被设置删除标记，新的记录被插入，最终删除标记的记录被清除。当一个二级索引记录被标记删除或者正在被更新，InnoDB通过聚簇索引查找数据库记录。在聚簇索引中，记录的**DB_TRX_ID**列被检查，如果行数据在读事物启动后有更改，那么将会从undo-log中检索正确版本。

如果一个二级索引记录被标记为删除或者索引页被一个新事物更新，那么索引覆盖功能不可用，InnoDB此时通过在聚簇索引查找数据进行返回。

#### 清除
> 由一个或多个后台线程周期执行的一种垃圾收集（由innodb_purge_threads控制）。清除操作解析和处理undo-log中的历史列表，找到被之前的delete语句标记为删除，且不会被MVCC和rollback用到的记录，以便用来清除聚簇索引和二级索引。

#### 历史列表
> 一个具有删除标记记录的事物列表，由InnoDB用来执行清除操作。记录在undo-log中。历史列表的长度由`show
> engine innodb
> status`展示。如果历史列表长度超过了**innodb_max_purge_lag**配置的值，那么每个DML语句都会稍微延迟，以便清除操作完成对删除记录的刷新。