* [返回上一级](../InnoDB锁与事物模型.md)

## 幻象行
在同一个事物中，当同样的查询条件，进行多次查询时获取的结果不一样，这样的问题就叫做幻象问题。例如一个查询执行了两次，第二次返回的数据行是第一次没有返回的，那么这些数据行就是幻象行。

假设表child中的id列上有一个索引，你想查询所有id大于100的数据行，以便稍后进行更新：
~~~
SELECT * FROM child WHERE id > 100 FOR UPDATE;
~~~
让表中包含id为90和102的行数据，查询会从id大于100的第一条索引记录开始扫描。如果只给扫描到的索引记录加锁，而不锁定索引记录间的范围，其它事物就可以插入id为101的行数据。此时如果在一个事物中再次进行查询，就会看到查询结果中多了一行id为101的行数据。这种幻读违反了事物隔离的原则。

为了阻止幻读，InnoDB使用了一种名为next-key lock的算法，这种算法将索引记录锁和区间锁关联起来。InnoDB以如下方式执行行锁，他给查询到的索引记录加共享锁或排他锁。因此行锁实际上就是索引记录锁。而next-key lock就是索引记录锁再加上此条记录之前的区间。如果一个会话在索引记录R上持有共享锁或排他锁，那么其它会话不能直接插入新的索引记录到R前面的区间。

当InnoDB扫描索引时，同样会给最后一条索引记录之后的区间加锁。例如为了阻止对id大于100的区间进行任何插入，除了90到102的区间被锁定，102之后的区间也会被锁定，因为102是最后一条数据。

你可以使用next-key lock对你的应用程序做唯一性检查：如果你用share mode读取了数据，并且这些数据中没有你要插入的行，那么你可以在后续过程中安全的插入数据，因为share mode下的next-key lock已经锁住了你要插入的行的区间。